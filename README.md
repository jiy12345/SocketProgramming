# SocketProgramming

- [v1.0 간단한 1대 1 에코 서버](#v1-0-간단한-1대-1-에코-서버) 
  - [주요 기능](#1-0-주요-기능)
  - [개선할 점](#1-0-개선할-점)
  - [실행 예시](#1-0-실행-예시)
- [v1.1 간단한 1대 다 에코 서버](#v1-1-간단한-1대-다-에코-서버) 
  - [주요 기능](#1-1-주요-기능)
  - [개선할 점](#1-1-개선할-점)
  - [실행 예시](#1-1-실행-예시)
- [v1.2 채팅 시스템](#v1-2-채팅-시스템) 
  - [주요 기능](#1-2-주요-기능)
  - [개선할 점](#1-2-개선할-점)
  - [실행 예시](#1-2-실행-예시)

## v1 0 간단한 1대 1 에코 서버
### 1 0 주요 기능
- 클라이언트 측 소켓
  - 블로킹 소켓 활용하여 서버와 연결 시도(connect)
  - 논 블로킹 소켓 활용하여 서버에 사용자로부터 입력받은 데이터 보내고 받기(send, recv)
- 서버 측 소켓
  - 리스닝 소켓
    - 클라이언트의 통신 요청을 받아들이기 위한 소켓 구현(bind, listen)
    - 클라이언트 통신 요청 받아들여 클라이언트와 통신하기위한 소켓 생성(accept)
  - 클라이언트와의 소통을 위한 소켓
    - 논 블로킹 소켓 활용하여 클라이언트의 데이터 받고 받은 데이터 다시 보내기
### 1 0 개선할 점
- 클라이언트 측
  - 클라이언트 측에서 논 블로킹 소켓을 활용하여 데이터를 보내고 받기는 했지만, fgets라는 입력 함수가 사용자로부터 입력이 들어올 때까지 제어를 반환하지 않으므로 실행이 막히게 된다. 따라서 논 블로킹 소켓을 활용하는 의미가 없어지게 된다.(1.1에서 해결)
  - 위 문제와 연결되는 문제인데, 데이터를 보내는 것과 받는 것이 같은 실행 흐름에서 이루어지다보니 사용자가 입력을 하여 데이터를 보내기 전까지 데이터를 받을 수 없다.(1.1에서 해결)
- 서버 측
  - accept를 하나만 받고 있으므로, 여러 클라이언트로부터의 통신 요청을 받는 것이 불가능하다.(1.1에서 해결)
### 1 0 실행 예시
![ResultImage1.0](https://github.com/jiy12345/SocketProgramming/blob/main/Images/Result%20Images/ResultImage1.0.png)
## v1 1 간단한 1대 다 에코 서버
### 1 1 주요 기능
- 클라이언트 측 소켓
  - 사용자 입력을 받고, 서버로 보내는 부분을 새로운 스레드 생성하여 구성
    - 따라서 1.0 버전과 달리 사용자가 입력했는지 여부와 상관 없이 서버로부터 입력을 바로 받아볼 수 있음
- 서버 측 소켓
  - 생성한 클라이언트 소켓별로 스레드 생성하여 각각의 연결마다 개별적인 스레드에서 send와 recv를 진행하도록 하기
    - 따라서 여러 클라이언트와 동시에 통신하는것이 가능해짐
### 1 1 개선할 점
- 공통 사항
  - 현재는 데이터를 보내고 받는 것만 가능하고, 데이터의 성질에 따른 다른 처리를 하는 것이 불가능함
- 서버측 소켓
  - 클라이언트 연결과 스레드가 1대 1 대응되도록 구현하였으므로, 지나치게 많은 스레드가 생성될 수 있음
### 1 1 실행 예시
![ResultImage1.1](https://github.com/jiy12345/SocketProgramming/blob/main/Images/Result%20Images/ResultImage1.1.png)
## v1 2 채팅 시스템
### 1 2 주요 기능
- 공통 사항
  - 서버와 클라이언트가 공통적으로 활용할 프로토콜을 추가하여, 데이터만 보내는 것이 아니라 데이터에 대한 정보를 헤더로 같이 보낼 수 있도록 함.
  - 패킷 헤더 구조체는 다음과 같음
```C++
#define PACKET_HEADER_SIZE 4
#pragma pack(push, 1) // 구조체 패딩을 1바이트 단위로 하도록 한다!
typedef struct
{
	short len;  // 패킷 헤더를 포함한 패킷 데이터의 크기
	short type; // 패킷 타입. 설명은 아래에
}PACKET_HEADER;
```
  - 현재 활용되는 패킷의 종류는 다음과 같음
```c++
#define PACKET_CHAR_MSG   1000      // client <-> server
                                    // 일반적인 데이터 전송을 위한 패킷
#define PACKET_CHATNAME_REQ   1001  // server -> client
                                    // 클라이언트에 사용자 이름을 요청하는 패킷
#define PACKET_NAME_REQ   2000		// client -> server
                                    // 클라이언트 측에서 사용자 이름을 입력하여 사용한다고 알리는 패킷
#define PACKET_NAME_ACK   3000		// server -> client
                                    // 사용자 이름이 사용 가능하다고 승인하는 패킷
#define PACKET_JOIN_USER  4000		// server -> client
                                    // 채팅창에 누군가가 이름을 승인받고 입장하였을 때 모든 사용자에게 보내기 위한 패킷
```
  - 메시지를 보낼 때 패킷 형태로 만들어 보내도록 함
  - 메시지를 받을 때 무조건 패킷 헤더를 먼저 완전히 받고 난 후 데이터를 받도록 함
    - 패킷 헤더에 입력된 패킷 데이터의 크기만큼의 데이터를 받아오도록 함
    - 패킷 헤더에 입력된 패킷 타입에 따라 다르게 처리하도록 함
- 클라이언트 측
  - 사용자에게 입력받아 서버로 데이터를 보내는 스레드를 생성하되, CREATE_SUSPENDED 옵션을 활용하여 사용자가 이름을 입력하고, 적절한 이름임을 서버에게 승인 받기 전까지는 동작하지 않도록 함
    - 사용자가 이름을 입력하는 것이 스레드상에서도 데이터로 보내지는 것을 방지하기 위함
- 서버 측
  - 사용자를 식별하고 필요한 데이터를 저장하기 위해 User 구조체 추가
    - accept로 새로운 클라이언트가 연결될 때마다 User 구조체를 생성하고, std::list에 추가하여 유지하며 필요할 때 찾아 사용할 수 있도록 한다.
    - User 구조체는 다음과 같음
```c++
struct User
{
	SOCKET client_socket;           // 클라이언트 소켓
	SOCKADDR_IN socket_address;     // 소켓의 주소 정보
	char client_name[9] = { 0, };   // 사용자가 정한 클라이언트 이름
	char recved_msg[255] = { 0, };  // 입력된 메시지
	int total_recved_bytes = 0;     // 현재까지 입력된 데이터의 총 바이트
                                    // 패킷 헤더를 입력받기 위해 활용
};
```
  - 클라이언트로부터 받은 메시지는 항상 모든 접속한 클라이언트에 전파
    - 사용자가 입장하였다는 메시지를 입장한 클라이언트를 제외한 모든 클라이언트에게 보내도록 함
    - 사용자가 입력한 채팅 데이터를 입력한 사용자 이름과 함께 모든 클라이언트에게 보내도록 함
### 1 2 개선할 점
- 공통 사항
  - 현재는 클라이언트가 보내는 모든 메시지가 모든 연결된 클라이언트에 전파되도록 되어있는데, 귓속말 등의 기능을 구현하기 위해서는 조금 더 다양한 패킷 타입과 그에 따른 처리 방식이 필요할 듯 하다.
- 클라이언트 측
  - 현재는 콘솔에 출력되도록 하고 있는데, 조금 더 편리한 사용을 위해서는 WIN API를 활용하여 출력하는 것이 좋을 듯 하다.
### 1 2 실행 예시
![ResultImage1.2](https://github.com/jiy12345/SocketProgramming/blob/main/Images/Result%20Images/ResultImage1.2.png)
